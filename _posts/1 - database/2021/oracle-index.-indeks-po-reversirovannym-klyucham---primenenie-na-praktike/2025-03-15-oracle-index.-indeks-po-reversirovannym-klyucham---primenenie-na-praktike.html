---
layout: post
title: Oracle PL/SQL. Индекс по реверсированным ключам - применение на практике
description: В данной статье разберем когда нужно создавать реверсированный индекс, когда его следует применять, увидим на примере как увеличивается скорость выполнения запроса. 
categories: database
catname: Базы данных
image: "images/database/2021/2021-02-01-oracle-plsql.-indeks-po-reversirovannym-klyucham---primenenie-na-praktike/1.jpg"
thumb: "images/database/2021/2021-02-01-oracle-plsql.-indeks-po-reversirovannym-klyucham---primenenie-na-praktike/1t.jpg"
permalink: "blog/:categories/:year-:month-:day-:slug.html"
---
<div class="post-body">

  <h2>Описание индекса</h2>
  <p>Относится к типу индексной структуры <b>B(balanced)-tree</b> (сбалансированное дерево). Скажу как в книге Тома Кайта - он реализован так, чтобы снизить конкуренцию за листовые блоки индекса в "правосторонних" индексах, такие как индексы на стобцах, которые заполяются последовательностями (например генерация первичного ключа).
  Реверсивный индекс позволяет распределить вставки по всем листовым блокам в индексе, но это может сделать индекс менее эффективно упакованным.
  </p>
  <h2>Когда применять</h2>
  <p>Когда одновременно много пользователей, хотят модифицировать одну и ту же строку и ищут ее через индекс, который автоматически генерируется. Это значит, что возникнет конкуренция за доступ к одному и тому же блоку. Реверсивный индекс поможет сократить время ожидание занятого буфера, возникающих в правой части занятого индекса.
  </p>
  <h2>Подготовка тестовых данных</h2>
  <p>Чтобы воспроизвести данные для теста, достаточно создать таблицу с 10 000 000 строк без первичного ключа. Как это сделать описано в предыдущей <a href="/blog/database/2021/2021-01-21-oracle-plsql.-sozdanie-svyazannyh-tablic-i-zapolnenie-ih-testovymi-dannymi.html">статье</a>.</p>
  <h2>Применение индекса</h2>
  <ul>
    <li>Замерим скорость до создания индекса, на примере вывода любого <span class="sql-table">id_oper</span>:
      <div class="sql-code-formatter">--включаем вывод данных для процедуры dbms_output.put_line
set serveroutput on;

--замеряем скорость
declare
  v_id_oper   number;
  v_start     timestamp;
  v_end       timestamp;
  v_exec_time interval day to second;
begin
  
  --фиксируем время начала выполнения
  v_start := systimestamp;
  
  --ищем любой id_op в таблице operation
  select id_oper
    into v_id_oper
    from operation 
    where id_oper = (select id_oper 
                      from operation
                      where rownum = 1); --первый попавшийся id_oper

  --фиксируем время завершения выполнения
  v_end := systimestamp;
  
  v_exec_time := v_end - v_start;
  
  dbms_output.put_line(v_exec_time);
end;</div>
Результат: +00 00:00:09.431000 <b>(9 секунд)</b> (у вас конечно же будет другое время)
    </li>
    <li>Создадим обычный индекс для поля <span class="sql-table">id_oper</span> таблицы <span class="sql-table">operation</span> (выполняться будет пару минут):
      <div class="sql-code-formatter">create index id_oper_idx on operation(id_oper);</div>
    </li>
    <li>Теперь снова замерим скорость скриптом из пункта 1. <br><br>
      Результат: +00 00:00:00.095000 <b>(9 сотых секунды)</b> 
    </li>
  </ul>
  <p><b>Итог</b>: было 9 секунд, стало 0.09 секунд, производительность увеличилась в ~100 раз!</p>
  <br>
  <p>Спасибо за внимание!</p>

</div>
